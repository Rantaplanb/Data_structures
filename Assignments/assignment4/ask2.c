#include <stdio.h>
#include <stdlib.h>

struct node{
    int data;
    int h; //height
    struct node* p; //parent
};

struct node* upTreeUnion(struct node* setRoot1, struct node* setRoot2)
{
    if(setRoot1->h >= setRoot2->h){
        setRoot2->p = setRoot1;
        if(setRoot1->h == setRoot2->h)
            setRoot1->h = setRoot1->h + 1;
        setRoot2->h = -1;
        return setRoot1;
    }
    else{
        setRoot1->p = setRoot2;
        setRoot1->h = -1;
        return setRoot2;
    }
};

//Just a simple driver program
int main()
{
    struct node n1, n2, n3, n4;
    n1.h = 0;
    n2.h = 0;
    n3.h = 0;
    n4.h = 0;
    n1.data = 1;
    n2.data = 2;
    n3.data = 3;
    n4.data = 4;
    n1.p = NULL;
    n2.p = NULL;
    n3.p = NULL;
    n4.p = NULL;
    struct node* set = upTreeUnion(&n1, &n2);
    struct node* set2 = upTreeUnion(&n3, &n4);
    set = upTreeUnion(set, set2);
    printf("%d", set->h);
}

/* Το υψος του δεντρου T που προκυπτει απο διαδοχικες συνενωσεις n συνολων μεγεθους 1 (θεωρω n>1)
   και λαμβανει ευρος τιμων στο διαστημα [1, logn]. To υψος εξαρταται απο την μεθοδο με την οποια
   πραγματοποιειται η συνενωση των n συνολων. Οπως καθισταται αντιληπτο απο τον αλγοριθμο 
   της upTreeUnion(), οταν συνενωνονται 2 συνολα, η μονη περιπτωση κατα την οποια η ενωση τους
   εχει αυξημενο υψος (κατα 1), ειναι η περιπτωση ενωσης δεντρων με h1=h2! Σε καθε αλλη
   περιπτωση h(new) = MAX(h1, h2), οπου h1 και h2 τα υψη των δεντρων των συνολων που ενωνονται.
   
   Ειπωθηκε στην λιστα του μαθηματος οτι αρκει να το δειξουμε με ενα παραδειγμα:
   Εστω οτι n = 16.
   
 ->Για να προκυψει ελαχιστο υψος εχω:
   Αρχικα συνενωνω 2 συνολα μεγεθους 1 και υψους 0, προκυπτει 1 συνολο μεγεθους 2 και υψους 1.
   Επειτα συνενωνω το συνολο μεγεθους 2 και υψους 1 με ενα συνολο μεγεθους 1 και υψους μηδεν
		Προκυπτει συνολο μεγεθους 3 και υψους 1.
   Επειτα συνενωνω το συνολο μεγεθους 3 και υψους 1 με ενα συνολο μεγεθους 1 και υψους μηδεν
		Προκυπτει συνολο μεγεθους 4 και υψους 1.
   Επειτα συνενωνω το συνολο μεγεθους 4 και υψους 1 με ενα συνολο μεγεθους 1 και υψους μηδεν
		Προκυπτει συνολο μεγεθους 5 και υψους 1.
	.
	.
	.
   Τελικα προκυπτει ενα συνολο μεγεθους 16 και υψους 1. (ελαχιστο δυνατο υψος)
   
   
 ->Για να προκυψει μεγιστο δυνατο υψος πρεπει να ενωνω συνεχως συνολα ιδιου υψους:
   Αρχικα συνενωνω 2 συνολα μεγεθους 1 και υψους 0, προκυπτει 1 συνολο μεγεθους 2 και υψους 1.
   Συνενωνω ξανα 2 συνολα μεγεθους 1 και υψους 0, προκυπτει 1 ακομα συνολο μεγεθους 2 και υψους 1.
   Συνενωνω τα 2 αυτα συνολα μεγεθους 2 και υψους 1, προκυπτει 1 συνολο μεγεθους 4 και υψους 2. 
   Με ομοιο τροπο φτιαχνω αλλα 3 συνολα μεγεθους 4 και υψους 2.
   Τα συνενωνω ανα 2 και προκυπτουν 2 συνολα μεγεθους 8 και υψους 3.
   Τελος, συνενωνω τα 2 αυτα συνολα μεγεθους 8 και υψους 3 ωστε να προκυψει το τελικο συνολο 
   μεγεθους 16 και υψους 4.
   
   Πραγματι h(max) = logn και h(min) = 1, για οποιαδηποτε τιμη του n. */
   
   